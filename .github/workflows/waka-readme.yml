name: Waka Readme

on:
  schedule:
    # Runs at 12am UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  update:
    name: Update README stats via PR
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout main
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          ref: main

      - name: Checkout or create waka-readme branch
        run: |
          git fetch origin waka-readme 2>/dev/null && git checkout waka-readme || git checkout -b waka-readme
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch WakaTime stats and update README
        env:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
        run: |
          set -euo pipefail

          # Fetch stats from WakaTime API
          AUTH=$(echo -n "$WAKATIME_API_KEY" | base64)
          STATS=$(curl -sf -H "Authorization: Basic $AUTH" \
            "https://wakatime.com/api/v1/users/current/stats/last_7_days")

          if [ -z "$STATS" ]; then
            echo "Failed to fetch WakaTime stats"
            exit 1
          fi

          # Extract data using jq
          TOTAL=$(echo "$STATS" | jq -r '.data.human_readable_total // "0 hrs"')
          DAILY_AVG=$(echo "$STATS" | jq -r '.data.human_readable_daily_average // "0 hrs"')
          BEST_DAY_DATE=$(echo "$STATS" | jq -r '.data.best_day.date // "N/A"')
          BEST_DAY_TIME=$(echo "$STATS" | jq -r '.data.best_day.text // "0 hrs"')
          RANGE_START=$(echo "$STATS" | jq -r '.data.start // ""' | cut -d'T' -f1)
          RANGE_END=$(echo "$STATS" | jq -r '.data.end // ""' | cut -d'T' -f1)

          # Build progress bar function (using braille blocks like athul/waka-readme)
          make_bar() {
            local pct=$1
            local blocks="â£€â£„â£¤â£¦â£¶â£·â£¿"
            local bar=""
            local full_blocks=$((pct * 25 / 100))
            local remainder=$(((pct * 25 % 100) * 7 / 100))

            for ((i=0; i<full_blocks; i++)); do
              bar+="${blocks:6:1}"
            done
            if [ $full_blocks -lt 25 ] && [ $remainder -gt 0 ]; then
              bar+="${blocks:$remainder:1}"
              full_blocks=$((full_blocks + 1))
            fi
            for ((i=full_blocks; i<25; i++)); do
              bar+="${blocks:0:1}"
            done
            echo "$bar"
          }

          # Format time with padding
          pad_time() {
            printf "%-16s" "$1"
          }

          pad_name() {
            printf "%-20s" "$1"
          }

          pad_pct() {
            printf "%6.2f %%" "$1"
          }

          # Generate languages section
          LANGUAGES=""
          while IFS= read -r line; do
            name=$(echo "$line" | jq -r '.name')
            text=$(echo "$line" | jq -r '.text')
            pct=$(echo "$line" | jq -r '.percent')
            bar=$(make_bar "${pct%.*}")
            LANGUAGES+="$(pad_name "$name")$(pad_time "$text")$bar   $(pad_pct "$pct")"$'\n'
          done < <(echo "$STATS" | jq -c '.data.languages[:5][]')

          # Generate editors section
          EDITORS=""
          while IFS= read -r line; do
            name=$(echo "$line" | jq -r '.name')
            text=$(echo "$line" | jq -r '.text')
            pct=$(echo "$line" | jq -r '.percent')
            bar=$(make_bar "${pct%.*}")
            EDITORS+="$(pad_name "$name")$(pad_time "$text")$bar   $(pad_pct "$pct")"$'\n'
          done < <(echo "$STATS" | jq -c '.data.editors[:3][]')

          # Generate OS section
          OS_STATS=""
          while IFS= read -r line; do
            name=$(echo "$line" | jq -r '.name')
            text=$(echo "$line" | jq -r '.text')
            pct=$(echo "$line" | jq -r '.percent')
            bar=$(make_bar "${pct%.*}")
            OS_STATS+="$(pad_name "$name")$(pad_time "$text")$bar   $(pad_pct "$pct")"$'\n'
          done < <(echo "$STATS" | jq -c '.data.operating_systems[:3][]')

          # Generate projects section
          PROJECTS=""
          while IFS= read -r line; do
            name=$(echo "$line" | jq -r '.name')
            text=$(echo "$line" | jq -r '.text')
            pct=$(echo "$line" | jq -r '.percent')
            bar=$(make_bar "${pct%.*}")
            PROJECTS+="$(pad_name "$name")$(pad_time "$text")$bar   $(pad_pct "$pct")"$'\n'
          done < <(echo "$STATS" | jq -c '.data.projects[:5][]')

          # Generate categories section (AI Coding, Coding, Writing Docs, etc.)
          CATEGORIES=""
          while IFS= read -r line; do
            name=$(echo "$line" | jq -r '.name')
            text=$(echo "$line" | jq -r '.text')
            pct=$(echo "$line" | jq -r '.percent')
            bar=$(make_bar "${pct%.*}")
            CATEGORIES+="$(pad_name "$name")$(pad_time "$text")$bar   $(pad_pct "$pct")"$'\n'
          done < <(echo "$STATS" | jq -c '.data.categories[:5][]')

          # Get current timestamp
          UPDATED=$(date -u "+%Y-%m-%d %H:%M:%S UTC")

          # Build the full stats section
          STATS_CONTENT="
          \`\`\`txt
          ðŸ“… ${RANGE_START} - ${RANGE_END}
          â±ï¸  Total: ${TOTAL}  |  Daily Avg: ${DAILY_AVG}  |  Best Day: ${BEST_DAY_DATE} (${BEST_DAY_TIME})

          ðŸ’» Languages
          ${LANGUAGES}
          ðŸ› ï¸  Editors
          ${EDITORS}
          ðŸ–¥ï¸  Operating Systems
          ${OS_STATS}
          ðŸ“ Projects
          ${PROJECTS}
          ðŸ“Š Categories
          ${CATEGORIES}\`\`\`

          _Last updated: ${UPDATED}_"

          # Clean up the content (remove leading spaces from heredoc)
          STATS_CONTENT=$(echo "$STATS_CONTENT" | sed 's/^          //')

          # Update README between markers
          awk -v content="$STATS_CONTENT" '
            /<!--START_SECTION:waka-->/ { print; print content; skip=1; next }
            /<!--END_SECTION:waka-->/ { skip=0 }
            !skip { print }
          ' README.md > README.tmp && mv README.tmp README.md

          # Stage changes
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to README.md"
          else
            git commit -m "chore(waka): update weekly development stats"
            echo "Changes committed"
          fi

      - name: Push waka-readme branch
        run: |
          git push origin waka-readme || git push -u origin waka-readme

      - name: Create or update PR
        id: create-pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          repo="reesey275/reesey275"
          base="main"
          head="waka-readme"
          title="chore(waka): update weekly stats"
          body="Automated WakaTime stats update from GitHub Actions.

          **Stats Include:**
          - ðŸ’» Languages breakdown
          - ðŸ› ï¸ Editors used
          - ðŸ–¥ï¸ Operating systems
          - ðŸ“ Active projects
          - ðŸ“Š Activity categories (AI Coding, Coding, Docs)"

          # Fetch latest main to compare against
          git fetch origin main

          # Check for ACTUAL file differences (not commit count)
          if git diff --quiet origin/main -- README.md; then
            echo "No file changes detected - stats unchanged"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "README.md has changes:"
          git diff --stat origin/main -- README.md
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

          # Check if PR already exists
          pr_number=$(gh pr list --repo "$repo" --head "$head" --base "$base" --json number -q '.[0].number' 2>/dev/null || echo "")

          if [ -z "$pr_number" ]; then
            echo "Creating new PR..."
            gh pr create --repo "$repo" --base "$base" --head "$head" --title "$title" --body "$body"
          else
            echo "Updating existing PR #$pr_number..."
            gh pr edit "$pr_number" --repo "$repo" --title "$title" --body "$body"
          fi

      - name: Wait for checks and auto-merge
        if: steps.create-pr.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          repo="reesey275/reesey275"
          head="waka-readme"
          base="main"

          # Get the PR number
          pr_number=$(gh pr list --repo "$repo" --head "$head" --base "$base" --json number -q '.[0].number')
          echo "PR #$pr_number is ready for merge"

          # Wait for checks (up to 5 minutes)
          for i in {1..30}; do
            status=$(gh pr checks "$pr_number" --repo "$repo" 2>/dev/null | grep -c "pass" || echo "0")
            if [ "$status" -gt "0" ]; then
              echo "Checks passed, attempting auto-merge..."
              gh pr merge "$pr_number" --repo "$repo" --squash --auto || echo "Auto-merge not enabled or PR not ready yet"
              break
            fi
            echo "Waiting for checks... ($i/30)"
            sleep 10
          done
